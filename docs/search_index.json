[["analise-geoespacial.html", "Capítulo 7 Analise geoespacial", " Capítulo 7 Analise geoespacial Dados espaciais são os que utilizam o sistema de coordenadas cartesianas com três (x, y e z) ou mais dimensões. Dados geoespaciais são dados que podem ser mapeados no planeta Terra e relacionadas com outros dados baseados em sistemas de coordenadas geográficas. Como grande parte dos dados ambientais são afetados pela localização geográfica, a análise geoespacial traz informações importantes (Bivand, Pebesma, and Gómez-Rubio 2008; Davis 2022). Conforme Zanetti (2017), um sistema de projeção é uma a forma de projetar a superfície da Terra numa superfície plana, ou seja, uma superfície de referência. As chamadas superfícies de referência são simples, regulares e com características geométricas já conhecidas e, por isso, servem de base para cálculos e representações (Zanetti 2017). O sistema de referência ou datum utilizado nacionalmente, desde os anos 2000, é o Sistema de referência Geocêntrico para as Américas (SIRGAS2000). Internacionalmente, utiliza-se o World Geodetic System of 1984 (WGS84) comumente. Basicamente, o SGR é um sistema de coordenadas definido a partir de um elipsóide de referência, posicionado e orientado em relação à superfície da Terra. A partir dele, é possível localizar espacialmente qualquer feição na superfície terrestre. Os mais conhecidos são: SAD69, WGS84 e o SIRGAS 2000. O sistema Universal Transverso de Mercator, conhecido como sistema UTM, é o sistema de coordenadas utilizado para o mapeamento do território brasileiro. Sendo M.C a sigla de Meridiano Central, de acordo com Zanetti (2017): Cada coordenada ou ponto dos dados espaciais podem ter associado a eles uma informação, que é denominada {atributo}. Um conjunto de pontos ordenados é denominado {linha} e uma área fechada formada por uma ou mais linhas é um {polígono}. Já uma Grade (Grid) é formado por linhas verticais e horizontais (Bivand, Pebesma, and Gómez-Rubio 2008). O restante da teoria por trás da análise geoespacial já é coberta pela disciplina de Cartografia e Geoprocessamento, portanto, aqui iremos abordar somente a parte prática. No capítulo, serão utilizados os seguintes pacotes: sf para ler e trabalhar com dados espaciais e mapview para a etapa de criação de mapas. No curso de Engenharia Ambiental e Urbana, utilizam-se shapefiles (.shp) para realizar análises espaciais, portanto, estes serão utilizados no capítulo. A utilização de rasters não será abordada. References "],["aplicação-3.html", "Aplicação", " Aplicação Para a aplicação será reproduzido o exemplo do TBEP R Training. Para isso, serão instalados os pacotes sf e mapview. options(repos = list(CRAN=&quot;http://cran.rstudio.com/&quot;)) options(&quot;install.lock&quot;=FALSE) install.packages(c(&#39;sf&#39;,&#39;mapview&#39;)) library(sf) library(mapview) library(ggplot2) install.packages(&quot;tidyverse&quot;) #library(tidyverse) O shapefile “sgdat.shp” são dados da cobertura de algas marinhas em Tampa Bay em 2016. As “features” são as linhas do vetor e os “fields” são as colunas, ou melhor, atributos (“OBJECT ID” e “FLUCCS”). O SGR do arquivo é WGS 84. A coluna “geometry” armazena os dados espaciais (longitude e latitude). Esse é o passo a passo de como importar um shapefile. Porém, muitas vezes não possuímos um shapefile e queremos criar um a partir de um dataframe. Para isso, é necessário que o dataframe inclua as coordenadas geográficas (longitude e latitude) e que tenhamos conhecimento do SGR. O dataframe ´fishdat´ possui as características dos peixes encontrados e o statloc apresenta a localização deles. O passo a passo será realizado abaixo. # dados da presença de peixes em Tampa Bay fishdat &lt;- read.csv(&quot;Data/fishdat.csv&quot;) #localização geográfica dos peixes statloc &lt;- read.csv(&quot;Data/statloc.csv&quot;) # estrutura dos dados str(fishdat) ## &#39;data.frame&#39;: 2844 obs. of 12 variables: ## $ OBJECTID : int 1550020 1550749 1550750 1550762 1550828 1550838 1550842 1551131 1551311 1551335 ... ## $ Reference : chr &quot;TBM1996032006&quot; &quot;TBM1996032004&quot; &quot;TBM1996032004&quot; &quot;TBM1996032207&quot; ... ## $ Sampling_Date: chr &quot;1996-03-20&quot; &quot;1996-03-20&quot; &quot;1996-03-20&quot; &quot;1996-03-22&quot; ... ## $ yr : int 1996 1996 1996 1996 1996 1996 1996 1996 1996 1996 ... ## $ Gear : int 300 22 22 20 160 300 300 300 300 22 ... ## $ ExDate : chr &quot;2018-04-12 10:27:38&quot; &quot;2018-04-12 10:25:23&quot; &quot;2018-04-12 10:25:23&quot; &quot;2018-04-12 10:25:23&quot; ... ## $ Bluefish : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Common.Snook : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Mullets : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Pinfish : int 0 54 0 80 0 0 0 0 1 1 ... ## $ Red.Drum : int 0 0 1 0 4 0 0 0 0 0 ... ## $ Sand.Seatrout: int 1 0 0 0 0 1 5 66 0 0 ... str(statloc) ## &#39;data.frame&#39;: 2173 obs. of 3 variables: ## $ Reference: chr &quot;TBM1996032006&quot; &quot;TBM1996032004&quot; &quot;TBM1996032207&quot; &quot;TBM1996042601&quot; ... ## $ Latitude : num 27.9 27.9 27.9 28 27.9 ... ## $ Longitude: num -82.6 -82.6 -82.5 -82.7 -82.6 ... Para isso, utilizaremos a função st_as_sf() para transformar o dataframe em um objeto sf. Primeiramente, precisamos juntar os dois datasets (fishdat e statloc) e dizer qual coluna que possui os dados da geometria (latitude e longitude). Além disso, é necessário dizer qual o SGR e, além disso, precisamos garantir que ambos datasets possuam o mesmo SGR. Por enquanto, podemos fazer um “chute calibrado” que é o WGS84. #juntando os dois dataframes library(dplyr) joindata &lt;- left_join(fishdat,statloc,by=&quot;Reference&quot;) #criando o objeto de dados espaciais joindata &lt;- st_as_sf(joindata, coords=c(&#39;Longitude&#39;,&#39;Latitude&#39;), crs = st_crs(sgdat)) #tipo de objeto sf str(joindata) ## Classes &#39;sf&#39; and &#39;data.frame&#39;: 2844 obs. of 13 variables: ## $ OBJECTID : int 1550020 1550749 1550750 1550762 1550828 1550838 1550842 1551131 1551311 1551335 ... ## $ Reference : chr &quot;TBM1996032006&quot; &quot;TBM1996032004&quot; &quot;TBM1996032004&quot; &quot;TBM1996032207&quot; ... ## $ Sampling_Date: chr &quot;1996-03-20&quot; &quot;1996-03-20&quot; &quot;1996-03-20&quot; &quot;1996-03-22&quot; ... ## $ yr : int 1996 1996 1996 1996 1996 1996 1996 1996 1996 1996 ... ## $ Gear : int 300 22 22 20 160 300 300 300 300 22 ... ## $ ExDate : chr &quot;2018-04-12 10:27:38&quot; &quot;2018-04-12 10:25:23&quot; &quot;2018-04-12 10:25:23&quot; &quot;2018-04-12 10:25:23&quot; ... ## $ Bluefish : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Common.Snook : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Mullets : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Pinfish : int 0 54 0 80 0 0 0 0 1 1 ... ## $ Red.Drum : int 0 0 1 0 4 0 0 0 0 0 ... ## $ Sand.Seatrout: int 1 0 0 0 0 1 5 66 0 0 ... ## $ geometry :sfc_POINT of length 2844; first list element: &#39;XY&#39; num -82.6 27.9 ## - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA NA NA NA NA ... ## ..- attr(*, &quot;names&quot;)= chr [1:12] &quot;OBJECTID&quot; &quot;Reference&quot; &quot;Sampling_Date&quot; &quot;yr&quot; ... #checando SGR st_crs(joindata) ## Coordinate Reference System: ## User input: WGS 84 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;latitude&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;longitude&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4326]] st_crs(sgdat) ## Coordinate Reference System: ## User input: WGS 84 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;latitude&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;longitude&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4326]] Caso seja necessário modificar a projeção, utiliza-se a função `st_transform(). Nesse caso, não precisamos modificar já que o shapefile (sgdat) tem o mesmo SGR do que estamo querendo criar. Agora, iniciaremos a análise geoespacial dos dados. Inicialmente, iremos dar uma olhada geral para entender qual os dados que estamos lidando. O padrão é que a função ´plot()´ plote todas as feições. Para plotar somente a geometria, utiliza-se st_geometry(). plot(st_geometry(joindata)) plot(joindata) plot(sgdat) Conforme observamos o shapefile “sgdat” com os dados das algas marinhas e o “joindata” com os dados do posicionamento de peixes, é possível verificar que existem áreas de intersecção entre ambos. Para analisar novamente, iremos plotar somente a geometria de ambos: plot(joindata$geometry) plot(sgdat$geometry) Vamos filtrar somente os dados dos peixes do ano de 2016: filt_data &lt;- joindata %&gt;% filter(yr == 2016) plot(st_geometry(filt_data)) Agora, verificaremos quantos peixes foram vistos nos mesmos locais em que encontraram-se algas marinhas em 2016. Ou seja, iremos selecionar as localizações que possuem ambos dados. Para isso, iremos utilizar o código abaixo: fish_crop &lt;- filt_data[sgdat, ] plot(fish_crop$geometry) O que foi realizado até agora é somente a intersecção da geometria de ambos datasets. Portanto, agora realizaremos a intersecção de ambos dados, incluindo atributos: fish_int &lt;- st_intersection(filt_data, sgdat) plot(st_geometry(fish_int)) View(fish_int) É possível utilizar ferramentas do tidyverse. Abaixo, iremos fazer a soma de todos os Pinfish foram pegos em 2016: fish_cnt &lt;- fish_int %&gt;% group_by(FLUCCS) %&gt;% summarise( cnt = sum(Pinfish) ) fish_cnt ## Simple feature collection with 2 features and 2 fields ## Geometry type: MULTIPOINT ## Dimension: XY ## Bounding box: xmin: -82.7182 ymin: 27.82623 xmax: -82.53237 ymax: 28.02418 ## Geodetic CRS: WGS 84 ## # A tibble: 2 × 3 ## FLUCCS cnt geometry ## &lt;chr&gt; &lt;int&gt; &lt;MULTIPOINT [°]&gt; ## 1 9113 1559 ((-82.53352 27.92907), (-82.53617 27.91043), (-82.53535 27.91212… ## 2 9116 4766 ((-82.55893 27.96612), (-82.5588 27.96633), (-82.55797 27.96632)… Além de realizar a soma nos atributos numéricos (quantidade de Pinfish), também é realizada nos atributos geométricos (latitude e longitude). Conforme apresentado na tabela anterior, existe uma maior quantidade de Pinfishs em áreas onde existe maior quantidade de algas marinhas (FLUCCS=9116). É possível realizar um gráfico em relação às duas categorias de cobertura de algas marinhas (´9113´: desigual, ´9116´: contínua). ggplot(fish_cnt, aes(x = FLUCCS, y = cnt)) + geom_bar(stat = &#39;identity&#39;, fill=&#39;navyblue&#39;) Agora será realizada a confecção de mapas. Utilizaremos os pacotes ggplot2 inicialmente: ggplot() + geom_sf(data = sgdat, fill = &#39;green&#39;) + geom_sf(data = joindata) Agora, para criar um mapa interativo para selecionar e dar zoom nos dados, utilizaremos o pacote mapview: mapview(sgdat, col.regions = &#39;green&#39;) + mapview(joindata, zcol = &#39;Gear&#39;) "],["material-complementar-2.html", "Material Complementar", " Material Complementar TBEP R Training (youtube) "]]
