[["analise-geoespacial.html", "Capítulo 7 Analise geoespacial", " Capítulo 7 Analise geoespacial Dados espaciais são os que utilizam o sistema de coordenadas cartesianas com três (x, y e z) ou mais dimensões. Dados geoespaciais são dados que podem ser mapeados no planeta Terra e relacionadas com outros dados baseados em sistemas de coordenadas geográficas. Como grande parte dos dados ambientais são afetados pela localização geográfica, a análise geoespacial traz informações importantes (Bivand, Pebesma, and Gómez-Rubio 2008; Davis 2022). Conforme Zanetti (2017), um sistema de projeção é uma a forma de projetar a superfície da Terra numa superfície plana, ou seja, uma superfície de referência. As chamadas superfícies de referência são simples, regulares e com características geométricas já conhecidas e, por isso, servem de base para cálculos e representações (Zanetti 2017). O sistema de referência ou datum utilizado nacionalmente, desde os anos 2000, é o Sistema de referência Geocêntrico para as Américas (SIRGAS2000). Internacionalmente, utiliza-se o World Geodetic System of 1984 (WGS84) comumente. Basicamente, o SGR é um sistema de coordenadas definido a partir de um elipsóide de referência, posicionado e orientado em relação à superfície da Terra. A partir dele, é possível localizar espacialmente qualquer feição na superfície terrestre. Os mais conhecidos são: SAD69, WGS84 e o SIRGAS 2000. O sistema Universal Transverso de Mercator, conhecido como sistema UTM, é o sistema de coordenadas utilizado para o mapeamento do território brasileiro. Sendo M.C a sigla de Meridiano Central, de acordo com Zanetti (2017): Cada coordenada ou ponto dos dados espaciais podem ter associado a eles uma informação, que é denominada {atributo}. Um conjunto de pontos ordenados é denominado {linha} e uma área fechada formada por uma ou mais linhas é um {polígono}. Já uma Grade (Grid) é formado por linhas verticais e horizontais (Bivand, Pebesma, and Gómez-Rubio 2008). O restante da teoria por trás da análise geoespacial já é coberta pela disciplina de Cartografia e Geoprocessamento, portanto, aqui iremos abordar somente a parte prática. No capítulo, serão utilizados os seguintes pacotes: sf para ler e trabalhar com dados espaciais e mapview para a etapa de criação de mapas. No curso de Engenharia Ambiental e Urbana, utilizam-se shapefiles (.shp) para realizar análises espaciais, portanto, estes serão utilizados no capítulo. A utilização de rasters não será abordada. References "],["aplicações.html", "Aplicações", " Aplicações 7.0.1 Relação entre quantidade de algas e de peixes em Tampa Bay Para a aplicação será reproduzido o exemplo do TBEP R Training. Para isso, serão instalados os pacotes sf e mapview. options(repos = list(CRAN=&quot;http://cran.rstudio.com/&quot;)) options(&quot;install.lock&quot;=FALSE) install.packages(c(&#39;sf&#39;,&#39;mapview&#39;)) library(sf) library(mapview) library(ggplot2) # graphic library(tidyverse) library(dplyr) # data manipulation library(readr) # read files O shapefile “sgdat.shp” são dados da cobertura de algas marinhas em Tampa Bay em 2016. As “features” são as linhas do vetor e os “fields” são as colunas, ou melhor, atributos (“OBJECT ID” e “FLUCCS”). O SGR do arquivo é WGS 84. A coluna “geometry” armazena os dados espaciais (longitude e latitude). Esse é o passo a passo de como importar um shapefile. Porém, muitas vezes não possuímos um shapefile e queremos criar um a partir de um dataframe. Para isso, é necessário que o dataframe inclua as coordenadas geográficas (longitude e latitude) e que tenhamos conhecimento do SGR. O dataframe ´fishdat´ possui as características dos peixes encontrados e o statloc apresenta a localização deles. O passo a passo será realizado abaixo. # dados da presença de peixes em Tampa Bay fishdat &lt;- read.csv(&quot;Data/fishdat.csv&quot;) #localização geográfica dos peixes statloc &lt;- read.csv(&quot;Data/statloc.csv&quot;) # estrutura dos dados str(fishdat) ## &#39;data.frame&#39;: 2844 obs. of 12 variables: ## $ OBJECTID : int 1550020 1550749 1550750 1550762 1550828 1550838 1550842 1551131 1551311 1551335 ... ## $ Reference : chr &quot;TBM1996032006&quot; &quot;TBM1996032004&quot; &quot;TBM1996032004&quot; &quot;TBM1996032207&quot; ... ## $ Sampling_Date: chr &quot;1996-03-20&quot; &quot;1996-03-20&quot; &quot;1996-03-20&quot; &quot;1996-03-22&quot; ... ## $ yr : int 1996 1996 1996 1996 1996 1996 1996 1996 1996 1996 ... ## $ Gear : int 300 22 22 20 160 300 300 300 300 22 ... ## $ ExDate : chr &quot;2018-04-12 10:27:38&quot; &quot;2018-04-12 10:25:23&quot; &quot;2018-04-12 10:25:23&quot; &quot;2018-04-12 10:25:23&quot; ... ## $ Bluefish : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Common.Snook : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Mullets : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Pinfish : int 0 54 0 80 0 0 0 0 1 1 ... ## $ Red.Drum : int 0 0 1 0 4 0 0 0 0 0 ... ## $ Sand.Seatrout: int 1 0 0 0 0 1 5 66 0 0 ... str(statloc) ## &#39;data.frame&#39;: 2173 obs. of 3 variables: ## $ Reference: chr &quot;TBM1996032006&quot; &quot;TBM1996032004&quot; &quot;TBM1996032207&quot; &quot;TBM1996042601&quot; ... ## $ Latitude : num 27.9 27.9 27.9 28 27.9 ... ## $ Longitude: num -82.6 -82.6 -82.5 -82.7 -82.6 ... Para isso, utilizaremos a função st_as_sf() para transformar o dataframe em um objeto sf. Primeiramente, precisamos juntar os dois datasets (fishdat e statloc) e dizer qual coluna que possui os dados da geometria (latitude e longitude). Além disso, é necessário dizer qual o SGR e, além disso, precisamos garantir que ambos datasets possuam o mesmo SGR. Por enquanto, podemos fazer um “chute calibrado” que é o WGS84. #juntando os dois dataframes library(dplyr) joindata &lt;- left_join(fishdat,statloc,by=&quot;Reference&quot;) #criando o objeto de dados espaciais joindata &lt;- st_as_sf(joindata, coords=c(&#39;Longitude&#39;,&#39;Latitude&#39;), crs = st_crs(sgdat)) #tipo de objeto sf str(joindata) ## Classes &#39;sf&#39; and &#39;data.frame&#39;: 2844 obs. of 13 variables: ## $ OBJECTID : int 1550020 1550749 1550750 1550762 1550828 1550838 1550842 1551131 1551311 1551335 ... ## $ Reference : chr &quot;TBM1996032006&quot; &quot;TBM1996032004&quot; &quot;TBM1996032004&quot; &quot;TBM1996032207&quot; ... ## $ Sampling_Date: chr &quot;1996-03-20&quot; &quot;1996-03-20&quot; &quot;1996-03-20&quot; &quot;1996-03-22&quot; ... ## $ yr : int 1996 1996 1996 1996 1996 1996 1996 1996 1996 1996 ... ## $ Gear : int 300 22 22 20 160 300 300 300 300 22 ... ## $ ExDate : chr &quot;2018-04-12 10:27:38&quot; &quot;2018-04-12 10:25:23&quot; &quot;2018-04-12 10:25:23&quot; &quot;2018-04-12 10:25:23&quot; ... ## $ Bluefish : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Common.Snook : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Mullets : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Pinfish : int 0 54 0 80 0 0 0 0 1 1 ... ## $ Red.Drum : int 0 0 1 0 4 0 0 0 0 0 ... ## $ Sand.Seatrout: int 1 0 0 0 0 1 5 66 0 0 ... ## $ geometry :sfc_POINT of length 2844; first list element: &#39;XY&#39; num -82.6 27.9 ## - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA NA NA NA NA ... ## ..- attr(*, &quot;names&quot;)= chr [1:12] &quot;OBJECTID&quot; &quot;Reference&quot; &quot;Sampling_Date&quot; &quot;yr&quot; ... #checando SGR st_crs(joindata) ## Coordinate Reference System: ## User input: WGS 84 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;latitude&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;longitude&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4326]] st_crs(sgdat) ## Coordinate Reference System: ## User input: WGS 84 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;latitude&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;longitude&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4326]] Caso seja necessário modificar a projeção, utiliza-se a função `st_transform(). Nesse caso, não precisamos modificar já que o shapefile (sgdat) tem o mesmo SGR do que estamo querendo criar. Agora, iniciaremos a análise geoespacial dos dados. Inicialmente, iremos dar uma olhada geral para entender qual os dados que estamos lidando. O padrão é que a função ´plot()´ plote todas as feições. Para plotar somente a geometria, utiliza-se st_geometry(). plot(st_geometry(joindata)) plot(joindata) plot(sgdat) Conforme observamos o shapefile “sgdat” com os dados das algas marinhas e o “joindata” com os dados do posicionamento de peixes, é possível verificar que existem áreas de intersecção entre ambos. Para analisar novamente, iremos plotar somente a geometria de ambos: plot(joindata$geometry) plot(sgdat$geometry) Vamos filtrar somente os dados dos peixes do ano de 2016: filt_data &lt;- joindata %&gt;% filter(yr == 2016) plot(st_geometry(filt_data)) Agora, verificaremos quantos peixes foram vistos nos mesmos locais em que encontraram-se algas marinhas em 2016. Ou seja, iremos selecionar as localizações que possuem ambos dados. Para isso, iremos utilizar o código abaixo: fish_crop &lt;- filt_data[sgdat, ] plot(fish_crop$geometry) O que foi realizado até agora é somente a intersecção da geometria de ambos datasets. Portanto, agora realizaremos a intersecção de ambos dados, incluindo atributos: fish_int &lt;- st_intersection(filt_data, sgdat) plot(st_geometry(fish_int)) View(fish_int) É possível utilizar ferramentas do tidyverse. Abaixo, iremos fazer a soma de todos os Pinfish foram pegos em 2016: fish_cnt &lt;- fish_int %&gt;% group_by(FLUCCS) %&gt;% summarise( cnt = sum(Pinfish) ) fish_cnt ## Simple feature collection with 2 features and 2 fields ## Geometry type: MULTIPOINT ## Dimension: XY ## Bounding box: xmin: -82.7182 ymin: 27.82623 xmax: -82.53237 ymax: 28.02418 ## Geodetic CRS: WGS 84 ## # A tibble: 2 × 3 ## FLUCCS cnt geometry ## &lt;chr&gt; &lt;int&gt; &lt;MULTIPOINT [°]&gt; ## 1 9113 1559 ((-82.53352 27.92907), (-82.53617 27.91043), (-82.53535 27.91212… ## 2 9116 4766 ((-82.55893 27.96612), (-82.5588 27.96633), (-82.55797 27.96632)… Além de realizar a soma nos atributos numéricos (quantidade de Pinfish), também é realizada nos atributos geométricos (latitude e longitude). Conforme apresentado na tabela anterior, existe uma maior quantidade de Pinfishs em áreas onde existe maior quantidade de algas marinhas (FLUCCS=9116). É possível realizar um gráfico em relação às duas categorias de cobertura de algas marinhas (´9113´: desigual, ´9116´: contínua). ggplot(fish_cnt, aes(x = FLUCCS, y = cnt)) + geom_bar(stat = &#39;identity&#39;, fill=&#39;navyblue&#39;) Agora será realizada a confecção de mapas. Utilizaremos os pacotes ggplot2 inicialmente: ggplot() + geom_sf(data = sgdat, fill = &#39;green&#39;) + geom_sf(data = joindata) Agora, para criar um mapa interativo para selecionar e dar zoom nos dados, utilizaremos o pacote mapview: mapview(sgdat, col.regions = &#39;green&#39;) + mapview(joindata, zcol = &#39;Gear&#39;) 7.0.2 Pontos de incêndio nas florestas brasileiras Para a segunda aplicação, será utilizada uma base de dados do kaggle com os pontos e a quantidade de incêndios nas florestas brasileiras. # Data frame com os incêndios e os estados brasileiros # fonte: https://www.kaggle.com/code/tianjinglei/starter-forest-fires-in-brazil-41eec699-a/input forest_fires &lt;- read.csv(&quot;Data/amazon.csv&quot;) head(forest_fires) ## year state month number date ## 1 1998 Acre Janeiro 0 1998-01-01 ## 2 1999 Acre Janeiro 0 1999-01-01 ## 3 2000 Acre Janeiro 0 2000-01-01 ## 4 2001 Acre Janeiro 0 2001-01-01 ## 5 2002 Acre Janeiro 0 2002-01-01 ## 6 2003 Acre Janeiro 10 2003-01-01 View(forest_fires) str(forest_fires) ## &#39;data.frame&#39;: 6454 obs. of 5 variables: ## $ year : int 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 ... ## $ state : chr &quot;Acre&quot; &quot;Acre&quot; &quot;Acre&quot; &quot;Acre&quot; ... ## $ month : chr &quot;Janeiro&quot; &quot;Janeiro&quot; &quot;Janeiro&quot; &quot;Janeiro&quot; ... ## $ number: num 0 0 0 0 0 10 0 12 4 0 ... ## $ date : chr &quot;1998-01-01&quot; &quot;1999-01-01&quot; &quot;2000-01-01&quot; &quot;2001-01-01&quot; ... Analisando a base de dados, é possível perceber que houveram problemas na leitura de estados que possuem acento no nome, como Pará e Piauí. Para resolver isso: # Problema com a palavra &quot;Pará&quot; porque tem um acento e o R não está conseguindo ler Encoding(forest_fires$state) &lt;- &quot;latin1&quot; forest_fires$state[forest_fires$state == &#39;Parï¿½&#39;] &lt;- &#39;Para&#39; #Ajuste # Piauí tambémdeu problema forest_fires$state[forest_fires$state == &#39;Piau&#39;] &lt;- &#39;Piaui&#39; #Ajuste View(forest_fires) Para analisar a quantidade de incêndios ao longo dos anos nos estados brasileiros, será realizada a soma deles em cada estado: # Agrupando a soma dos incêndios por estado total_fires_by_state &lt;- forest_fires %&gt;% group_by(state) %&gt;% summarise(sum = sum(number)) # Visualizando a base de dados criada com a soma por estado View(total_fires_by_state) # Sumarização dos dados summary(total_fires_by_state) ## state sum ## Length:23 Min. : 3237 ## Class :character 1st Qu.:21059 ## Mode :character Median :25129 ## Mean :30388 ## 3rd Qu.:37750 ## Max. :96246 Para visualizar a quantidade de incêndios por estado, será realizado um gráfico de barras: # Gráfico de barras com a soma de incêncios por estado ggplot(total_fires_by_state, aes(x = state, y = sum)) + geom_bar(stat=&#39;identity&#39;) + coord_flip() Para poder realizar a criação de mapas, foi criado um arquivo com as coordenadas (retiradas do Google Maps) de cada um dos estados brasileiros em WGS84: # Dataframe com as coordenadas lat e long em WGS84 (fonte: google maps) coord &lt;- read.table(&quot;Data/coordenadas.txt&quot;, sep=&quot;,&quot;,dec=&quot;.&quot;,header = TRUE) View(coord) Para poder analisar a quantidade de incêndios no mapa, será realizada a junção entre a tabela com a quantidade de incêndio por estado e a tabela de coordenadas: # Juntando os dataframes joindata &lt;- inner_join(total_fires_by_state,coord,by=&quot;state&quot;) View(joindata) Para que as coordenadas da tabela sejam tratadas como simple features, será utilizada a função st_as_sf() para criar os pontos das coordenadas de acordo com a latitude e longitude: # Junção entre a tabela com as coordenadas e a quantidade de incêndios: joindata2 &lt;- inner_join(total_fires_by_state,coord,by=&quot;state&quot;) %&gt;% st_as_sf(coords=c(&#39;long&#39;,&#39;lat&#39;), crs=4326) # criação dos pontos com as coordenadas e inserção do CRS de referência Para poder visualizar cada um dos pontos com os limites geográficos dos estados brasileiros, será importado um shapefile do IBGE. Sabe-se que os shapefiles do IBGE como CRS o SIRGAS 2000 e isso será confirmado a partir da função ´st_crs()´. # Importando shapefile (fonte: ibge) shape &lt;- read_sf(&#39;Data/Shapefiles/BR_UF_2020.shp&#39;) # por ser do ibge, utiliza crs = SIRGAS2000 (EPSG code: 4674), precisamos mudar para WGS84 st_crs(shape) ## Coordinate Reference System: ## User input: SIRGAS 2000 ## wkt: ## GEOGCRS[&quot;SIRGAS 2000&quot;, ## DATUM[&quot;Sistema de Referencia Geocentrico para las AmericaS 2000&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## USAGE[ ## SCOPE[&quot;Horizontal component of 3D system.&quot;], ## AREA[&quot;Latin America - Central America and South America - onshore and offshore. Brazil - onshore and offshore.&quot;], ## BBOX[-59.87,-122.19,32.72,-25.28]], ## ID[&quot;EPSG&quot;,4674]] View(shape) Como o objetivo é a visualização da ´joindata´ e do shapefile em um mesmo mapa, ambos precisam estar com o mesmo CRS. Dessa forma, o shapefile do IBGE será transformado em WGS84 a partir da função `st_transform: shape2 &lt;- st_transform(shape, 4326) # Mudando crs para WGS84 (EPSG code: 4326) st_crs(shape2) ## Coordinate Reference System: ## User input: EPSG:4326 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## ENSEMBLE[&quot;World Geodetic System 1984 ensemble&quot;, ## MEMBER[&quot;World Geodetic System 1984 (Transit)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G730)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G873)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1150)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1674)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1762)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G2139)&quot;], ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]], ## ENSEMBLEACCURACY[2.0]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## USAGE[ ## SCOPE[&quot;Horizontal component of 3D system.&quot;], ## AREA[&quot;World.&quot;], ## BBOX[-90,-180,90,180]], ## ID[&quot;EPSG&quot;,4326]] Antes de criarmos os mapas, iremos checr se os CRS são os mesmos: # Checando SGR st_crs(joindata2) ## Coordinate Reference System: ## User input: EPSG:4326 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## ENSEMBLE[&quot;World Geodetic System 1984 ensemble&quot;, ## MEMBER[&quot;World Geodetic System 1984 (Transit)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G730)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G873)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1150)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1674)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1762)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G2139)&quot;], ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]], ## ENSEMBLEACCURACY[2.0]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## USAGE[ ## SCOPE[&quot;Horizontal component of 3D system.&quot;], ## AREA[&quot;World.&quot;], ## BBOX[-90,-180,90,180]], ## ID[&quot;EPSG&quot;,4326]] st_crs(shape2) ## Coordinate Reference System: ## User input: EPSG:4326 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## ENSEMBLE[&quot;World Geodetic System 1984 ensemble&quot;, ## MEMBER[&quot;World Geodetic System 1984 (Transit)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G730)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G873)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1150)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1674)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1762)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G2139)&quot;], ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]], ## ENSEMBLEACCURACY[2.0]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## USAGE[ ## SCOPE[&quot;Horizontal component of 3D system.&quot;], ## AREA[&quot;World.&quot;], ## BBOX[-90,-180,90,180]], ## ID[&quot;EPSG&quot;,4326]] O primeiro mapa será um mapa interativo: # Mapa Interativo com os pontos no mapa do Brasil mapview(shape2, col.regions = &#39;green&#39;) + mapview(joindata2) O segundo mapa levará em conta a quantidade de incêndio em cada estado. Será criada uma escala de cor de acordo com a quantidade de incêndios. Assim, poderemos analisar quais estados apresentam maior quantidade de incêndios nas florestas ao longo dos anos. # Mapa com tamanho de ponto diferente de acordo com a quantidade de incêndios ggplot() + geom_sf(data = shape2) + geom_sf(data = shape2, colour = &quot;green&quot;, fill = NA) + geom_point(data = joindata, mapping = aes(x = long, y = lat, colour = sum, size = 3)) + scale_colour_gradient2( low = &quot;yellow&quot;, mid = &quot;orange&quot;, high = &quot;red&quot;, midpoint = 30388) + coord_sf() + ggtitle(&quot;Pontos de incêndio no Brasil&quot;) "],["material-complementar-2.html", "Material Complementar", " Material Complementar TBEP R Training (youtube) "]]
