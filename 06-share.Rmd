# Analise geoespacial

[Dados espaciais](https://bookdown.org/igisc/EnvDataSci/spatial-data-and-maps.html) são os que utilizam o sistema de coordenadas cartesianas com três (x, y e z) ou mais dimensões. Dados geoespaciais são dados que podem ser mapeados no planeta Terra e relacionadas com outros dados baseados em sistemas de coordenadas geográficas. Como grande parte dos dados ambientais são afetados pela localização geográfica, a análise geoespacial traz informações importantes [@bivand2009; @davis2022].

Conforme @zanetti2017, um sistema de projeção é uma a forma de projetar a superfície da Terra numa superfície plana, ou seja, uma superfície de referência. As chamadas superfícies de referência são simples, regulares e com características geométricas já conhecidas e, por isso, servem de base para cálculos e representações [@zanetti2017].

O sistema de referência ou datum utilizado nacionalmente, desde os anos 2000, é o Sistema de referência Geocêntrico para as Américas (SIRGAS2000). Internacionalmente, utiliza-se o World Geodetic System of 1984 (WGS84) comumente.

Basicamente, o SGR é um sistema de coordenadas definido a partir de um elipsóide de referência, posicionado e orientado em relação à superfície da Terra. A partir dele, é possível localizar espacialmente qualquer feição na superfície terrestre. Os mais conhecidos são: SAD69, WGS84 e o SIRGAS 2000. 

O sistema Universal Transverso de Mercator, conhecido como sistema UTM, é o sistema de coordenadas utilizado para o mapeamento do território brasileiro. Sendo M.C a sigla de Meridiano Central, de acordo com @zanetti2017:

\begin{citacao}
O sistema é formado por 60 cilindros transversos e secantes ao elipsóide de revolução, abrangendo fusos de 6° de amplitude em longitude, compreendidos entre as longitudes múltiplas de 6°[...]. A numeração é contada a partir do antimeridiano de Greenwich, para leste, em coincidência com os fusos da carta do mundo ao milionésimo (0°, 6°, 12°, ..., 42°, 48°, 54°,..., 342°, 348°, 354°). Cada fuso possui um meridiano central (M.C.) que está nas longitudes
múltiplas de 6° + 3 (3°, 9°, 15°,..., 45°, 51°, 57°,...., 345°, 351°, 357°).
\end{citacao}

Cada coordenada ou ponto dos dados espaciais podem ter associado a eles uma informação, que é denominada {atributo}. Um conjunto de pontos ordenados é denominado {linha} e uma área fechada formada por uma ou mais linhas é um {polígono}. Já uma Grade (Grid) é formado por linhas verticais e horizontais [@bivand2009].

O restante da teoria por trás da análise geoespacial já é coberta pela disciplina de Cartografia e Geoprocessamento, portanto, aqui iremos abordar somente a parte prática.

No capítulo, serão utilizados os seguintes pacotes: `sf` para ler e trabalhar com dados espaciais e `mapview` para a etapa de criação de mapas.

No curso de Engenharia Ambiental e Urbana, utilizam-se *shapefiles* (.shp) para realizar análises espaciais, portanto, estes serão utilizados no capítulo. A utilização de rasters não será abordada.


## Aplicações {-}
### Pontos de incêndio nas florestas brasileiras
Para a segunda aplicação, será utilizada uma base de dados do kaggle com os pontos e a quantidade de incêndios nas florestas brasileiras. Para isso, serão instalados os pacotes abaixo.

```{r 6-1,message=FALSE,warning=FALSE, results='hide'}
options(repos = list(CRAN="http://cran.rstudio.com/"))
options("install.lock"=FALSE)

install.packages(c('sf','mapview'))

library(sf)
library(mapview)
library(ggplot2)     # graphic
library(tidyverse)
library(dplyr)       # data manipulation
library(readr)       # read files
```

O dataset foi retirado do Kaggle e o link está apresentado no code chunk abaixo.
```{r 6-15,message=FALSE,warning=FALSE}
# Data frame com os incêndios e os estados brasileiros
# fonte: https://www.kaggle.com/code/tianjinglei/starter-forest-fires-in-brazil-41eec699-a/input

forest_fires <- read.csv("Data/amazon.csv")
head(forest_fires)
View(forest_fires)
str(forest_fires)

```

Analisando a base de dados, é possível perceber que houveram problemas na leitura de estados que possuem acento no nome, como Pará e Piauí. Para resolver isso:

```{r 6-16}
# Problema com a palavra "Pará" porque tem um acento e o R não está conseguindo ler

Encoding(forest_fires$state) <- "latin1"
forest_fires$state[forest_fires$state == 'Parï¿½'] <- 'Para' #Ajuste

# Piauí tambémdeu problema
forest_fires$state[forest_fires$state == 'Piau'] <- 'Piaui' #Ajuste
View(forest_fires)

```

Para analisar a quantidade de incêndios ao longo dos anos nos estados brasileiros, será realizada a soma deles em cada estado:

```{r 6-17}
# Agrupando a soma dos incêndios por estado

total_fires_by_state <- forest_fires %>%
  group_by(state) %>%
  summarise(sum = sum(number))

# Visualizando a base de dados criada com a soma por estado
View(total_fires_by_state)

# Sumarização dos dados
summary(total_fires_by_state)
```

Para visualizar a quantidade de incêndios por estado, será realizado um gráfico de barras:
```{r 6-18}
# Gráfico de barras com a soma de incêncios por estado
ggplot(total_fires_by_state, aes(x = state, y = sum)) +
  geom_bar(stat='identity') +
  coord_flip()

```

Para poder realizar a criação de mapas, foi criado um arquivo com as coordenadas (retiradas do Google Maps) de cada um dos estados brasileiros em WGS84:

```{r 6-19}
# Dataframe com as coordenadas lat e long em WGS84 (fonte: google maps)
coord <- read.table("Data/coordenadas.txt", sep=",",dec=".",header = TRUE)
View(coord)
```
Para poder analisar a quantidade de incêndios no mapa, será realizada a junção entre a tabela com a quantidade de incêndio por estado e a tabela de coordenadas:
```{r 6-20}

# Juntando os dataframes
joindata <- inner_join(total_fires_by_state,coord,by="state")
View(joindata)

```
Para que as coordenadas da tabela sejam tratadas como `simple features`, será utilizada a função `st_as_sf()` para criar os pontos das coordenadas de acordo com a latitude e longitude:
```{r 6-21}
# Junção entre a tabela com as coordenadas e a quantidade de incêndios:
joindata2 <- inner_join(total_fires_by_state,coord,by="state") %>%
  st_as_sf(coords=c('long','lat'), crs=4326) # criação dos pontos com as coordenadas e inserção do CRS de referência
```

Para poder visualizar cada um dos pontos com os limites geográficos dos estados brasileiros, será importado um shapefile do IBGE. Sabe-se que os shapefiles do IBGE como CRS o SIRGAS 2000 e isso será confirmado a partir da função ´st_crs()´.
```{r 6-22}
# Importando shapefile (fonte: ibge)

shape <- read_sf('Data/Shapefiles/BR_UF_2020.shp') # por ser do ibge, utiliza crs = SIRGAS2000 (EPSG code: 4674), precisamos mudar para WGS84
st_crs(shape)
View(shape)
```
Como o objetivo é a visualização da ´joindata´ e do shapefile em um mesmo mapa, ambos precisam estar com o mesmo CRS. Dessa forma, o shapefile do IBGE será transformado em WGS84 a partir da função ``st_transform`:

```{r 6-23}
shape2 <- st_transform(shape, 4326) # Mudando crs para WGS84 (EPSG code: 4326)
st_crs(shape2)
```

Antes de criarmos os mapas, iremos checr se os CRS são os mesmos:

```{r 6-24}
# Checando SGR
st_crs(joindata2) 
st_crs(shape2)
```
O primeiro mapa será um mapa interativo:

```{r 6-25}
# Mapa Interativo com os pontos no mapa do Brasil
mapview(shape2, col.regions = 'green') +
  mapview(joindata2)
```

O segundo mapa levará em conta a quantidade de incêndio em cada estado. Será criada uma escala de cor de acordo com a quantidade de incêndios. Assim, poderemos analisar quais estados apresentam maior quantidade de incêndios nas florestas ao longo dos anos.

```{r 6-26}
# Mapa com cor de ponto diferente de acordo com a quantidade de incêndios
ggplot() + 
  geom_sf(data = shape2) + 
  geom_sf(data = shape2, colour = "green", fill = NA) + 
  geom_point(data = joindata, mapping = aes(x = long, y = lat, colour = sum, size = 3)) +
    scale_colour_gradient2(
    low = "yellow", 
    mid = "orange", 
    high = "red",
    midpoint = 30388) +
  coord_sf() +
  ggtitle("Pontos de incêndio no Brasil")
```

### Relação entre quantidade de algas e de peixes em Tampa Bay
Para a aplicação será reproduzido o exemplo do [TBEP R Training](https://tbep-tech.github.io/tbep-r-training/mapping.html#Exercise_13). O shapefile "sgdat.shp" são dados da cobertura de algas marinhas em Tampa Bay em 2016. As "features" são as linhas do vetor e os "fields" são as colunas, ou melhor, atributos ("OBJECT ID" e "FLUCCS"). O SGR do arquivo é WGS 84. A coluna "geometry" armazena os dados espaciais (longitude e latitude).

```{r 6-2,message=FALSE,warning=FALSE,results='hide',echo=FALSE}
#sgdat shapefile
sgdat <- st_read('Data/sgdat.shp')

# utilidades do pacote sf
methods(class="sf")

```
Esse é o passo a passo de como importar um shapefile. Porém, muitas vezes não possuímos um shapefile e queremos criar um a partir de um dataframe. Para isso, é necessário que o dataframe inclua as coordenadas geográficas (longitude e latitude) e que tenhamos conhecimento do SGR. O dataframe ´fishdat´ possui as características dos peixes encontrados e o statloc apresenta a localização deles. O passo a passo será realizado abaixo.

```{r 6-3,message=FALSE,warning=FALSE}

# dados da presença de peixes em Tampa Bay
fishdat <- read.csv("Data/fishdat.csv")

#localização geográfica dos peixes
statloc <- read.csv("Data/statloc.csv")

```

```{r 6-4,message=FALSE,warning=FALSE}
# estrutura dos dados
str(fishdat)
str(statloc)

```
Para isso, utilizaremos a função `st_as_sf()` para transformar o dataframe em um objeto sf. Primeiramente, precisamos juntar os dois *datasets* (fishdat e statloc) e dizer qual coluna que possui os dados da geometria (latitude e longitude). Além disso, é necessário dizer qual o SGR e, além disso, precisamos garantir que ambos datasets possuam o mesmo SGR. Por enquanto, podemos fazer um "chute calibrado" que é o WGS84.

```{r 6-5,message=FALSE,warning=FALSE}
#juntando os dois dataframes
library(dplyr)
joindata <- left_join(fishdat,statloc,by="Reference")

#criando o objeto de dados espaciais
joindata <- st_as_sf(joindata, coords=c('Longitude','Latitude'), crs = st_crs(sgdat))

#tipo de objeto sf
str(joindata)

#checando SGR
st_crs(joindata)
st_crs(sgdat) 

```
Caso seja necessário modificar a projeção, utiliza-se a função ``st_transform()`. Nesse caso, não precisamos modificar já que o shapefile (sgdat) tem o mesmo SGR do que estamo querendo criar. 

Agora, iniciaremos a **análise geoespacial** dos dados. Inicialmente, iremos dar uma olhada geral para entender qual os dados que estamos lidando. 

O padrão é que a função ´plot()´ plote todas as feições. Para plotar somente a geometria, utiliza-se `st_geometry()`.


```{r 6-6,message=FALSE,warning=FALSE}
plot(st_geometry(joindata)) 
```
```{r,message=FALSE,warning=FALSE}
plot(joindata)

```
```{r,message=FALSE,warning=FALSE}
plot(sgdat)
```

Conforme observamos o shapefile "sgdat" com os dados das algas marinhas e o "joindata" com os dados do posicionamento de peixes, é possível verificar que existem áreas de intersecção entre ambos. Para analisar novamente, iremos plotar somente a geometria de ambos:

```{r 6-7,message=FALSE,warning=FALSE}
plot(joindata$geometry)
plot(sgdat$geometry)
```

Vamos filtrar somente os dados dos peixes do ano de 2016:
```{r 6-8,message=FALSE,warning=FALSE}
filt_data <- joindata %>%
  filter(yr == 2016)
plot(st_geometry(filt_data))
```

Agora, verificaremos quantos peixes foram vistos nos mesmos locais em que encontraram-se algas marinhas em 2016. Ou seja, iremos selecionar as localizações que possuem ambos dados. Para isso, iremos utilizar o código abaixo:
```{r 6-9,message=FALSE,warning=FALSE}

fish_crop <- filt_data[sgdat, ]

plot(fish_crop$geometry)

```
O que foi realizado até agora é somente a intersecção da geometria de ambos datasets. Portanto, agora realizaremos a intersecção de ambos dados, incluindo atributos:

```{r 6-10,message=FALSE,warning=FALSE}

fish_int <- st_intersection(filt_data, sgdat)

plot(st_geometry(fish_int))

View(fish_int)
```

É possível utilizar ferramentas do `tidyverse`. Abaixo, iremos fazer a soma de todos os Pinfish foram pegos em 2016:

```{r 6-11,message=FALSE,warning=FALSE}

fish_cnt <- fish_int %>% 
  group_by(FLUCCS) %>% 
  summarise(
    cnt = sum(Pinfish)
  ) 

fish_cnt

```
Além de realizar a soma nos atributos numéricos (quantidade de Pinfish), também é realizada nos atributos geométricos (latitude e longitude). Conforme apresentado na tabela anterior, existe uma maior quantidade de Pinfishs em áreas onde existe maior quantidade de algas marinhas (FLUCCS=9116). É possível realizar um gráfico em relação às duas categorias de cobertura de algas marinhas (´9113´: desigual, ´9116´: contínua).

```{r 6-12,message=FALSE,warning=FALSE}
ggplot(fish_cnt, aes(x = FLUCCS, y = cnt)) + 
  geom_bar(stat = 'identity', fill='navyblue') 
  
```
Agora será realizada a **confecção de mapas**. Utilizaremos os pacotes `ggplot2` inicialmente:

```{r 6-13,message=FALSE,warning=FALSE}

ggplot() + 
  geom_sf(data = sgdat, fill = 'green') + 
  geom_sf(data = joindata) 

```
Agora, para criar um mapa interativo para selecionar e dar zoom nos dados, utilizaremos o pacote `mapview`:

```{r 6-14,message=FALSE,warning=FALSE}

mapview(sgdat, col.regions = 'green') +
  mapview(joindata, zcol = 'Gear')

```


## Material Complementar {-}
1. [TBEP R Training (youtube)](https://www.youtube.com/watch?v=nQVFqkifeSE&t=152s)






