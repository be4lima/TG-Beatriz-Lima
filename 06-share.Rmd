# Analise geoespacial

[Dados espaciais](https://bookdown.org/igisc/EnvDataSci/spatial-data-and-maps.html) são os que utilizam o sistema de coordenadas cartesianas com três (x, y e z) ou mais dimensões. Dados geoespaciais são dados que podem ser mapeados no planeta Terra e relacionadas com outros dados baseados em sistemas de coordenadas geográficas. Como grande parte dos dados ambientais são afetados pela localização geográfica, a análise geoespacial traz informações importantes [@bivand2009; @davis2022].

Conforme @zanetti2017, um sistema de projeção é uma a forma de projetar a superfície da Terra numa superfície plana, ou seja, uma superfície de referência. As chamadas superfícies de referência são simples, regulares e com características geométricas já conhecidas e, por isso, servem de base para cálculos e representações [@zanetti2017].

O sistema de referência ou datum utilizado nacionalmente, desde os anos 2000, é o Sistema de referência Geocêntrico para as Américas (SIRGAS2000). Internacionalmente, utiliza-se o World Geodetic System of 1984 (WGS84) comumente.

Basicamente, o SGR é um sistema de coordenadas definido a partir de um elipsóide de referência, posicionado e orientado em relação à superfície da Terra. A partir dele, é possível localizar espacialmente qualquer feição na superfície terrestre. Os mais conhecidos são: SAD69, WGS84 e o SIRGAS 2000. 

O sistema Universal Transverso de Mercator, conhecido como sistema UTM, é o sistema de coordenadas utilizado para o mapeamento do território brasileiro. Sendo M.C a sigla de Meridiano Central, de acordo com @zanetti2017:

\begin{citacao}
O sistema é formado por 60 cilindros transversos e secantes ao elipsóide de revolução, abrangendo fusos de 6° de amplitude em longitude, compreendidos entre as longitudes múltiplas de 6°[...]. A numeração é contada a partir do antimeridiano de Greenwich, para leste, em coincidência com os fusos da carta do mundo ao milionésimo (0°, 6°, 12°, ..., 42°, 48°, 54°,..., 342°, 348°, 354°). Cada fuso possui um meridiano central (M.C.) que está nas longitudes
múltiplas de 6° + 3 (3°, 9°, 15°,..., 45°, 51°, 57°,...., 345°, 351°, 357°).
\end{citacao}

Cada coordenada ou ponto dos dados espaciais podem ter associado a eles uma informação, que é denominada {atributo}. Um conjunto de pontos ordenados é denominado {linha} e uma área fechada formada por uma ou mais linhas é um {polígono}. Já uma Grade (Grid) é formado por linhas verticais e horizontais [@bivand2009].

O restante da teoria por trás da análise geoespacial já é coberta pela disciplina de Cartografia e Geoprocessamento, portanto, aqui iremos abordar somente a parte prática.

No capítulo, serão utilizados os seguintes pacotes: `sf` para ler e trabalhar com dados espaciais e `mapview` para a etapa de criação de mapas.

No curso de Engenharia Ambiental e Urbana, utilizam-se *shapefiles* (.shp) para realizar análises espaciais, portanto, estes serão utilizados no capítulo. A utilização de rasters não será abordada.


## Aplicação {-}
Para a aplicação será reproduzido o exemplo do [TBEP R Training](https://tbep-tech.github.io/tbep-r-training/mapping.html#Exercise_13). Para isso, serão instalados os pacotes `sf` e `mapview`.

```{r chunk7-1,message=FALSE,warning=FALSE, results='hide'}
options(repos = list(CRAN="http://cran.rstudio.com/"))
options("install.lock"=FALSE)

install.packages(c('sf','mapview'))

library(sf)
library(mapview)
library(ggplot2)
install.packages("tidyverse")
#library(tidyverse)
```

O shapefile "sgdat.shp" são dados da cobertura de algas marinhas em Tampa Bay em 2016. As "features" são as linhas do vetor e os "fields" são as colunas, ou melhor, atributos ("OBJECT ID" e "FLUCCS"). O SGR do arquivo é WGS 84. A coluna "geometry" armazena os dados espaciais (longitude e latitude).

```{r,message=FALSE,warning=FALSE}
#sgdat shapefile
sgdat <- st_read('Data/sgdat.shp')

# utilidades do pacote sf
methods(class="sf")

```
Esse é o passo a passo de como importar um shapefile. Porém, muitas vezes não possuímos um shapefile e queremos criar um a partir de um dataframe. Para isso, é necessário que o dataframe inclua as coordenadas geográficas (longitude e latitude) e que tenhamos conhecimento do SGR. O dataframe ´fishdat´ possui as características dos peixes encontrados e o statloc apresenta a localização deles. O passo a passo será realizado abaixo.

```{r,message=FALSE,warning=FALSE}
getwd()
# dados da presença de peixes em Tampa Bay
fishdat <- read.csv("Data/fishdat.csv")

#localização geográfica dos peixes
statloc <- read.csv("Data/statloc.csv")

```

```{r,message=FALSE,warning=FALSE}
# estrutura dos dados
str(fishdat)
str(statloc)

```
Para isso, utilizaremos a função `st_as_sf()` para transformar o dataframe em um objeto sf. Primeiramente, precisamos juntar os dois *datasets* (fishdat e statloc) e dizer qual coluna que possui os dados da geometria (latitude e longitude). Além disso, é necessário dizer qual o SGR e, além disso, precisamos garantir que ambos datasets possuam o mesmo SGR. Por enquanto, podemos fazer um "chute calibrado" que é o WGS84.

```{r,message=FALSE,warning=FALSE}
#juntando os dois dataframes
library(dplyr)
joindata <- left_join(fishdat,statloc,by="Reference")

#criando o objeto de dados espaciais
joindata <- st_as_sf(joindata, coords=c('Longitude','Latitude'), crs = st_crs(sgdat))

#tipo de objeto sf
str(joindata)

#checando SGR
st_crs(joindata)
st_crs(sgdat) 

```
Caso seja necessário modificar a projeção, utiliza-se a função ``st_transform()`. Nesse caso, não precisamos modificar já que o shapefile (sgdat) tem o mesmo SGR do que estamo querendo criar. 

Agora, iniciaremos a **análise geoespacial** dos dados. Inicialmente, iremos dar uma olhada geral para entender qual os dados que estamos lidando. 

O padrão é que a função ´plot()´ plote todas as feições. Para plotar somente a geometria, utiliza-se `st_geometry()`.


```{r,message=FALSE,warning=FALSE}
plot(st_geometry(joindata)) 
```
```{r,message=FALSE,warning=FALSE}
plot(joindata)

```
```{r,message=FALSE,warning=FALSE}
plot(sgdat)
```

Conforme observamos o shapefile "sgdat" com os dados das algas marinhas e o "joindata" com os dados do posicionamento de peixes, é possível verificar que existem áreas de intersecção entre ambos. Para analisar novamente, iremos plotar somente a geometria de ambos:

```{r,message=FALSE,warning=FALSE}
plot(joindata$geometry)
plot(sgdat$geometry)
```

Vamos filtrar somente os dados dos peixes do ano de 2016:
```{r,message=FALSE,warning=FALSE}
filt_data <- joindata %>%
  filter(yr == 2016)
plot(st_geometry(filt_data))
```

Agora, verificaremos quantos peixes foram vistos nos mesmos locais em que encontraram-se algas marinhas em 2016. Ou seja, iremos selecionar as localizações que possuem ambos dados. Para isso, iremos utilizar o código abaixo:
```{r,message=FALSE,warning=FALSE}

fish_crop <- filt_data[sgdat, ]

plot(fish_crop$geometry)

```
O que foi realizado até agora é somente a intersecção da geometria de ambos datasets. Portanto, agora realizaremos a intersecção de ambos dados, incluindo atributos:

```{r,message=FALSE,warning=FALSE}

fish_int <- st_intersection(filt_data, sgdat)

plot(st_geometry(fish_int))

View(fish_int)
```

É possível utilizar ferramentas do `tidyverse`. Abaixo, iremos fazer a soma de todos os Pinfish foram pegos em 2016:

```{r,message=FALSE,warning=FALSE}

fish_cnt <- fish_int %>% 
  group_by(FLUCCS) %>% 
  summarise(
    cnt = sum(Pinfish)
  ) 

fish_cnt

```
Além de realizar a soma nos atributos numéricos (quantidade de Pinfish), também é realizada nos atributos geométricos (latitude e longitude). Conforme apresentado na tabela anterior, existe uma maior quantidade de Pinfishs em áreas onde existe maior quantidade de algas marinhas (FLUCCS=9116). É possível realizar um gráfico em relação às duas categorias de cobertura de algas marinhas (´9113´: desigual, ´9116´: contínua).

```{r,message=FALSE,warning=FALSE}
ggplot(fish_cnt, aes(x = FLUCCS, y = cnt)) + 
  geom_bar(stat = 'identity', fill='navyblue') 
  
```
Agora será realizada a **confecção de mapas**. Utilizaremos os pacotes `ggplot2` inicialmente:

```{r,message=FALSE,warning=FALSE}

ggplot() + 
  geom_sf(data = sgdat, fill = 'green') + 
  geom_sf(data = joindata) 

```
Agora, para criar um mapa interativo para selecionar e dar zoom nos dados, utilizaremos o pacote `mapview`:

```{r,message=FALSE,warning=FALSE}

mapview(sgdat, col.regions = 'green') +
  mapview(joindata, zcol = 'Gear')

```


## Material Complementar {-}
1. [TBEP R Training (youtube)](https://www.youtube.com/watch?v=nQVFqkifeSE&t=152s)






